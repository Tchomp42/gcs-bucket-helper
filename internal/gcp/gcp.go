package gcp

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"cloud.google.com/go/iam"
	admin "cloud.google.com/go/iam/admin/apiv1"
	"cloud.google.com/go/storage"
	"github.com/pkg/errors"
	"golang.org/x/oauth2"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/option"
	adminpb "google.golang.org/genproto/googleapis/iam/admin/v1"

	"github.com/athera-io/gcs-bucket-helper/internal/executor"
	"github.com/athera-io/gcs-bucket-helper/internal/input"
	"github.com/google/uuid"
)

// GCP is responsible for executing GCP operations
type GCP struct {
	// Both clients are instantiated after we have a token
	storageClient *storage.Client
	iamClient     *admin.IamClient
}

// New ...
func New() *GCP {
	return &GCP{}
}

func (g *GCP) instantiateClients(ctx context.Context, tok *oauth2.Token) error {
	tokSource := oauth2.StaticTokenSource(tok)

	storageClient, err := storage.NewClient(ctx, option.WithTokenSource(tokSource))

	if err != nil {
		return errors.Wrap(err, "Failed instantiating GCP Storage Client")
	}

	g.storageClient = storageClient

	iamClient, err := admin.NewIamClient(ctx, option.WithTokenSource(tokSource))

	if err != nil {
		return errors.Wrap(err, "Failed instantiating GCP IAM Service Account Client")
	}

	g.iamClient = iamClient

	return nil
}

// Execute ...
func (g *GCP) Execute(tok *oauth2.Token, data *executor.Data) error {

	ctx := context.Background() // Make new context so that server can return authentication success to user

	if err := g.instantiateClients(ctx, tok); err != nil {
		return err
	}

	defer func() {
		if err := g.iamClient.Close(); err != nil {
			log.Print("Error: Failed closing GCP IAM Service Account Client: ", err)
		}
	}()

	fmt.Println("") // Line break for legibility

	g.fillData(ctx, data)

	serviceAccount, err := g.makeServiceAccount(ctx, data)

	if err != nil {
		return err
	}

	// Sleep avoids race condition where Google sometimes does not recognize service account that was just created
	time.Sleep(time.Second)

	return g.makeBucket(ctx, serviceAccount, data)
}

func (g *GCP) fillData(ctx context.Context, data *executor.Data) {
	data.GCP.Project = input.Recv("Enter your GCP project name")

	data.GCP.Bucket = uuid.New().String()

	fmt.Println("- We have autogenerated the bucket name:", data.GCP.Bucket)

	inputBucketName := input.Recv(
		"If you want to override the autogenerated name then input a name, otherwise leave blank",
		// Validator: Bucket with that name must not already exist
		func(bucketName string) error {

			// Use autogenerated bucket name
			if bucketName == "" {
				return nil
			}

			bucket := g.storageClient.Bucket(bucketName)
			_, err := bucket.Attrs(ctx)

			// Bucket does not exist
			if err == storage.ErrBucketNotExist {
				return nil
			}

			// Bucket exists and user has access to it
			if err == nil {
				failMsg := "Bucket already exists, and you have permission to access it"
				return errors.New(failMsg)
			}

			// Bucket exists and user does not have access to it
			if errGoogleAPI, ok := err.(*googleapi.Error); ok && errGoogleAPI.Code == http.StatusForbidden {
				failMsg := "Bucket already exists, but you do not have permission to access it"
				return errors.New(failMsg)
			}

			// Something else went wrong (but the bucket does not exist, so validator should pass)
			return nil
		},
		// Validator: Name must not contain illegal characters
		func(bucketName string) error {

			// Use autogenerated bucket name
			if bucketName == "" {
				return nil
			}

			pattern := "^[a-z1-9._-]+$"

			if match, _ := regexp.MatchString(pattern, bucketName); !match {
				failMsg := "Bucket names must contain only lowercase letters, numbers, dashes (-), underscores (_), and dots (.)"
				return errors.New(failMsg)
			}

			return nil
		},
		// Validator: Name must start and end with a letter
		func(bucketName string) error {

			// Use autogenerated bucket name
			if bucketName == "" {
				return nil
			}

			startPattern := "^[a-z1-9]"

			failMsg := "Bucket names must start and end with a number or letter"

			if match, _ := regexp.MatchString(startPattern, bucketName); !match {
				return errors.New(failMsg)
			}

			endPattern := "[a-z1-9]$"

			if match, _ := regexp.MatchString(endPattern, bucketName); !match {
				return errors.New(failMsg)
			}

			return nil
		},
		// Validator: Name must be appropriate length
		func(bucketName string) error {

			// Use autogenerated bucket name
			if bucketName == "" {
				return nil
			}

			if len(bucketName) < 3 || len(bucketName) > 63 {
				failMsg := "Bucket names must contain 3 to 63 characters"
				return errors.New(failMsg)
			}

			return nil
		},
		// Validator: Name must not have illegal substrings
		func(bucketName string) error {

			// Use autogenerated bucket name
			if bucketName == "" {
				return nil
			}

			if strings.HasPrefix(bucketName, "goog") {
				failMsg := "Bucket names cannot begin with the 'goog' prefix"
				return errors.New(failMsg)
			}

			return nil
		},
	)

	if inputBucketName != "" {
		data.GCP.Bucket = inputBucketName
	}
}

func (g *GCP) makeServiceAccount(ctx context.Context, data *executor.Data) (*adminpb.ServiceAccount, error) {

	createServiceAccountReq := &adminpb.CreateServiceAccountRequest{
		Name:      "projects/" + data.GCP.Project,
		AccountId: genServiceAccountID(data),
	}

	serviceAccount, err := g.iamClient.CreateServiceAccount(ctx, createServiceAccountReq)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating IAM Service Account")
	}

	createServiceAccountKeyReq := &adminpb.CreateServiceAccountKeyRequest{
		Name: serviceAccount.Name,
	}

	serviceAccountKey, err := g.iamClient.CreateServiceAccountKey(ctx, createServiceAccountKeyReq)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating IAM Service Account Key")
	}

	data.GCP.ServiceAccountPrivateData = serviceAccountKey.PrivateKeyData

	serviceAccountJSONPath := input.Recv(
		"Enter a path on your local machine to save your service account credentials",
		// Validator: Directories in path must already exist
		func(s string) error {

			dir, filename := filepath.Split(s)

			if isDirectoryName(filename) {
				stat, err := os.Stat(s)

				if os.IsNotExist(err) {
					return errors.New("No such directory: " + s)
				}

				if !stat.IsDir() {
					failMsg := fmt.Sprintf("File named %s already exists", filename)
					return errors.New(failMsg)
				}
			} else {
				if _, err := os.Stat(dir); os.IsNotExist(err) {
					// Custom error is more readable than error from package os
					return errors.New("No such directory: " + dir)
				}
			}

			return nil
		},
	)

	// Add filename to path if last element in path represents directory name
	_, serviceAccountJSONFilename := filepath.Split(serviceAccountJSONPath)
	if isDirectoryName(serviceAccountJSONFilename) {
		serviceAccountJSONPath = filepath.Join(serviceAccountJSONPath, createServiceAccountReq.AccountId+".json")
	}

	fmt.Println("- Saving service account credentials at " + serviceAccountJSONPath)

	f, err := os.Create(serviceAccountJSONPath)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating Service Account JSON file")
	}

	defer f.Close()

	if _, err := f.Write(serviceAccountKey.PrivateKeyData); err != nil {
		return nil, errors.Wrap(err, "Failed writing service account key")
	}

	return serviceAccount, nil
}

// isDirectoryName returns true if filename is a directory name.
// (N.B. We assume that if the filename has no extension, then the user intended last element in path to represent a directory)
func isDirectoryName(s string) bool {
	ls := strings.Split(s, ".")

	// No extension if there is no "." char
	return len(ls) == 1 ||
		// No extension if there is only one "." char, and that char is a prefix (because "." prefix represents hidden file, not extension)
		(len(ls) == 2 && strings.HasPrefix(s, "."))
}

func genServiceAccountID(data *executor.Data) string {
	maxServiceAccountIDLength := 30
	prefix := "athera-"
	bucketName := data.GCP.Bucket

	now := time.Now().Unix()
	timestamp := "-" + strconv.Itoa(int(now))

	for {
		// It is safe to measure bytes instead of runes because:
		// "Bucket names must contain only lowercase letters, numbers, dashes (-), underscores (_), and dots (.)".
		// Therefore, all legal characters have length of 1 byte
		// https://cloud.google.com/storage/docs/naming
		if len(prefix+bucketName+timestamp) > maxServiceAccountIDLength {
			bucketName = bucketName[:len(bucketName)-1]
		} else {
			break
		}
	}

	return prefix + bucketName + timestamp
}

func (g *GCP) makeBucket(ctx context.Context, serviceAccount *adminpb.ServiceAccount, data *executor.Data) error {

	bkt := g.storageClient.Bucket(data.GCP.Bucket)

	bucketRegion := input.Recv("Enter a region for your new GCS bucket (e.g. US, EU)")

	bktAttrs := &storage.BucketAttrs{
		Name:     data.GCP.Bucket,
		Location: bucketRegion,
	}

	if err := bkt.Create(ctx, serviceAccount.ProjectId, bktAttrs); err != nil {
		return errors.Wrap(err, "Failed creating GCS Bucket")
	}

	var policy iam.Policy
	policy.Add("user:"+data.User.Email, "roles/storage.admin")
	policy.Add("serviceAccount:"+serviceAccount.Email, "roles/storage.objectAdmin")

	iamHandle := bkt.IAM()

	if err := iamHandle.SetPolicy(ctx, &policy); err != nil {
		return errors.Wrap(err, "Failed setting Iam Policy")
	}

	return nil
}
